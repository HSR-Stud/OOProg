\section{Module und Datenkapseln \verweiscpp{10}}
	\begin{minipage}[t]{7 cm}
		\subsection{Motivation \verweiscpp{10.1}}
		\begin{compactitem}
			\item Arbeitsteilung: Grosse Programme werden von mehreren Personen entwickelt. Praktikabel ist, wenn nur eine Person an einer bestimmten Datei arbeitet.
			\item Effizienz: Eine Üœbersetzungseinheit (Datei) muss bei jeder Ä„nderung neu übersetzt werden (je grösser die Datei desto langsamer die Üœbersetzung)
			\item Strukturierung: Ein grosses Programm in mehrere vernünftige Teile (Baugruppen, Units) aufteilen (Divide and conquer) 
		\end{compactitem}
	\end{minipage}
	\hspace*{0.5cm}
	\begin{minipage}[t]{11 cm}
		\subsection{Nomenklatur Modul vs. Unit}
			\begin{compactitem}
				\item Ein Programmbaustein wird traditionell mit Modul (der oder das Modul) bezeichnet
				\item Der Test eines Moduls heisst folglich Modultest
				\item Das Vorgehen, welches Module generiert, heisst Modularisierung 
				\item Heute üblicher wird Modul mit Unit, der Test mit Unittest bezeichnet, das Vorgehen heisst weiterhin Modularisierung 
			\end{compactitem}
		\subsection{Ziele der Modularisierung}
			\begin{compactitem}
				\item Klare, möglichst schlanke Schnittstellen definieren
				\item Units so bilden, das Zusammengehörendes in einer Unit isoliert wird (Kohäsion soll hoch sein)
				\item Schnittstellen zwischen den Units sollen klein sein (Kopplung soll klein sein)
				\item Abhängigkeiten unter den Units sollen eine Hierarchie bilden, zirkuläre (gegenseitige) Abhängigkeiten müssen vermieden werden
			\end{compactitem}
	\end{minipage}
	
	\begin{minipage}[t]{8 cm}	
		\subsection{Vom Modul zur Datenkapsel \verweiscpp{10.2}}
			\begin{compactitem}	
			Eigenschaften einer Unit (eines Moduls):
				\item realisiert eine in sich abgeschlossene Aufgabe
				\item kommuniziert über ihre Schnittstelle mit der Umgebung
				\item kann ohne Kenntnisse ihres inneren Verhaltens in ein Gesamtsystem integriert werden (include Header)
				\item ihre Korrektheit kann ohne Kenntnis ihrer Einbettung in einem Gesamtsystem nachgewiesen werden (mittels Unittest)
			Die Schnittstelle beschreibt, was das Modul zur Verfügung stellt verbirgt dabei wie das Verhalten konkret realisiert ist (Geheimnisprinzip, Information Hiding). Der User der Unit darf keine Annahme Ã¼ber den inneren Aufbau machen. Der Entwickler der Unit kann deren inneren Aufbau verändern solange die Schnittstelle dadurch nicht ändert. 
			\end{compactitem}
		\subsection{Unitkonzept / Module und Datenkapseln in C++ \verweiscpp{10.3}}
			\begin{compactitem}	
			\item Interface definiert die Schnittstelle, d.h. die Deklarationen wie Funktionsprototypen, etc. (Schaufenster)
			\item Implementation: in diesem Teil sind die Unterprogramme definiert, d.h. auscodiert (Werkstatt)
			\item Das Interface wird in einer Headerdatei (*.h) beschrieben, die Implementation liegt in einer *.cpp- Datei
			\end{compactitem}
			\subsection{Die Schnittstellen-/Headerdatei \verweiscpp{10.3.1}}
			    Jede .h-Datei enthÃ¤lt als erste Anweisungsfolge (Umfasst die Punkte 2-7) eine Include-Guard welche MehrfacheinfÃ¼gen verhindert. Der Syntax lautet:
			    \lstinputlisting[language=C,tabsize=2]{code/includeguard.c}
			    Deklarationsreihenfolge in Headerdatei (*.h)  (Beispiel Kap 16.1)
				\begin{enumerate}
				\item Dateikommentar
				\item #include der verwendeten System-Header (iostream, etc.)
				      #include <...>
				\item #include der projektbezogenen Header (#include "...")
				\item Konstantendefinitionen
				\item typedefs und Definition von Strukturen
				\item Allenfalls extern-Deklaration von globalen Variablen
				\item Funktionsprototypen, inkl. Kommentare der Schnittstelle, bzw. Klassendeklarationen
				\end{enumerate}
			\subsection{Die Implementierungsdatei \verweiscpp{10.3.2}}
				Deklarationsreihenfolge in Implementierungsdatei (*.cpp) (Beispiel Kap 16.1)
				\begin{enumerate}
			 		\item Dateikommentar
					\item #include der verwendeten System-Header (iostream, etc.)
					      #include <...>
					\item #include der projektbezogenen Header (#include "...")
					\item PrÃ¤prozessor-Direktiven
					\item typedefs und Definition von Strukturen
					\item Funktionsprototypen von lokalen, internen Funktionen
					\item Definition von Funktionen und Klassen (Kommentare aus Headerdatei nicht wiederholen!!)
				\end{enumerate}
		\end{minipage}
		
		\begin{minipage}[t]{11 cm}
			\subsection{Buildprozess / Makefile}
			    Der Buildprozess erstellt aus den einzelnen Dateien einen ausfÃ¼hrbaren Code. Dazu werden zuerst alle *.cpp-Files compiliert.
			    Die daraus entstandenen Objektdatei mÃ¼ssen anschliessend gelinkt und somit zu einer aufÃ¼hrbaren Datei zusammengesetzt. Die Eingabe in der Konsole sieht wie folt aus:
			    \lstinputlisting[language=C,tabsize=2]{code/compileUnit.c}
				\begin{compactitem}
					\item Ein Programmbaustein wird traditionell mit Modul (der oder das Modul) bezeichnet
					\item Der Test eines Moduls heisst folglich Modultest
					\item Das Vorgehen, welches Module generiert, heisst Modularisierung 
					\item Heute Ã¼blicher wird Modul mit Unit, der Test mit Unittest bezeichnet, das Vorgehen heisst weiterhin Modularisierung 
				\end{compactitem}
			\subsection{Ziele der Modularisierung}
				\begin{compactitem}
					\item Klare, mÃ¶glichst schlanke Schnittstellen definieren
					\item Units so bilden, das ZusammengehÃ¶rendes in einer Unit isoliert wird (KohÃ¤sion soll hoch sein)
					\item Schnittstellen zwischen den Units sollen klein sein (Kopplung soll klein sein)
					\item AbhÃ¤ngigkeiten unter den Units sollen eine Hierarchie bilden, zirkulÃ¤re (gegenseitige) AbhÃ¤ngigkeiten mÃ¼ssen vermieden werden
				\end{compactitem}
		\end{minipage}
		
