\section{Klassenkonzept}
	\begin{minipage}[t]{7 cm}
		\subsection{Begriff der Klasse}
		\begin{compactitem}
			\item Eine Klasse ist eine Struktur (eine Struktur besteht nur aus Daten), die mit den 	Funktionen, welche auf diesen Daten arbeiten, erweitert wurde.
			\item Eine Klasse ist also eine Struktur, welche die Daten und die Funktionen auf diesen Daten in ein syntaktisches Konstrukt packt.
			\item Die Klasse ist die Umsetzung der Datenkapsel.
			\item Eine Klassendeklaration ist eine Typendefinition. Die Variablen einer Klasse
			werden als Objekte bezeichnet.
		\end{compactitem}
	\end{minipage}
	\hspace*{0.5cm}
	\begin{minipage}[t]{11 cm}
		\subsection{UML-Notation einer Klasse}
			\begin{tikzpicture}
				\begin{class}[text width=9.5cm]{ClassName}{0 ,0}
					\attribute {-attribute1: int = 0}
					\attribute {-attribute2: int = 0}
					\operation {+method1()}
					\operation {+method2()}
				\end{class}
			\end{tikzpicture}
			\begin{compactitem}
				\item Eine Klasse ist der Bauplan für Objekte.
				\item Eine Klasse besteht aus Daten (Attribute) und den Funktionen (Methoden) auf diesen Daten.
				\item Sichtbarkeit: 
				\begin{compactitem}
					\item $+$ : $public$
					\item $-$ : $private$
					\item $\#$ : $protected$
				\end{compactitem}
			\end{compactitem}
	\end{minipage}
	
	\begin{minipage}[t]{8 cm}	
		\subsection{Üblicher Aufbau einer Klassensyntax \verweiscpp{11.1.1}}
			\lstinputlisting[language=C++,tabsize=2]{code/klassenschnittstelle.cpp} 
			
			\subsubsection{Operationen einer Klasse}
					Operationen eine Klasse (= Funktionen, die im Klassenrumpf definiert sind) werden als
					Elementfunktionen oder Methoden bezeichnet.	Üblicherweise beginnen Elementfunktionen mit einem Kleinbuchstaben und werden in camelCase (mixedCase) notiert.	
					\begin{lstlisting}[language=C++,tabsize=2]
						isEmpty();
					\end{lstlisting}

			\subsubsection{Information Hiding}
				\begin{compactitem}
					\item Klassen exportieren generell ausschliesslich Methoden. Alle Daten sind im Innern (private-Abschnitt) verborgen, der Zugriff erfolgt über die so genannten Elementfunktionen.
					\item Jede Klasse besteht damit aus zwei Dateien, der Schnittstellendatei ($.h$) und	der Implementierungsdatei ($.cpp$).
				\end{compactitem}
	\end{minipage}
	\hspace*{0.5cm}
	\begin{minipage}[t]{10 cm}		
			\subsubsection{Zugriffsschutz \verweiscpp{11.4}}
			\begin{compactitem}
				\item $public$ - Elemente können innerhalb und von ausserhalb der Klasse
				angesprochen werden.
					\begin{compactitem}
						\item fast alle Methoden sind $public$
						\item Attribute sollen nie $public$ sein
					\end{compactitem}
				\item $protected$ - Elemente können von innerhalb der Klasse und von abgeleiteten
				Klassen angesprochen werden.
					\begin{compactitem}
						\item nur sparsam einsetzen!
					\end{compactitem}
				\item $private$ - Elemente können nur innerhalb der Klasse angesprochen werden.
					\begin{compactitem}
						\item grundsätzlich für alle Attribute und für einzelne (lokale) Methoden
					\end{compactitem}
			\end{compactitem}
				
				\paragraph{$friend$-Elemente \verweiscpp{11.4.2}}
					\begin{compactitem}
						\item $friend$ - Jede Klasse kann andere Klassen oder Funktionen zum Freund	erklären. Dadurch werden die Zugriffsregeln durchbrochen.
						\item Jeder $friend$ darf auf alle Elemente der Klasse zugreifen.
						\item $friend$ ist eine $C++$ - Spezialität, welche die meisten anderen
						Programmiersprachen (z.B. $Java$) nicht anbieten.
						\item $friends$, insbesondere $friend$-Klassen, können ein Anzeichen für
						schlechtes Design sein. Sie durchbrechen wichtige Prinzipien der objektorientierten Programmierung.
					\end{compactitem}
	\end{minipage}

\newpage
		\subsubsection{Beispiel an der Klasse Rechteck}
			\begin{minipage}[t]{9cm}
				\lstinputlisting[language=C++,tabsize=2]{code/class_rectangle_header.cpp}				
				\begin{tikzpicture}
					\begin{class}[text width=8cm]{Rectangle}{0 ,0}
						\attribute{-a : double}
						\attribute{-b : double}
						\operation{+setA(in newA : double)}
						\operation{+setB(in newB : double)}
						\operation{+getA() : double}
						\operation{+getB() : double}
						\operation{+getArea() : double}
					\end{class}
				\end{tikzpicture}
			\end{minipage}
			\hspace*{0.5cm}
			\begin{minipage}[t]{9 cm}
				\lstinputlisting[language=C++,tabsize=2]{code/class_rectangle.cpp} 
			\end{minipage}
			
	\begin{minipage}[t]{9cm}
		\subsection{Elementfunktionen \verweiscpp{11.2}}
			\begin{compactitem}
				\item sind Funktionen, die in der Schnittstelle der Klasse spezifiziert sind.
				\item Elementfunktionen haben vollen Zugriff auf alle Klassenelemente (auch auf
				solche, die mit private: gekennzeichnet sind.
				\item Auf Elementfunktionen kann nur unter Bezugnahme auf ein Objekt der Klasse, bzw. mit dem Scope-Operator (::) zugegriffen werden.
				\item Elementfunktionen sollen prinzipiell in der Implementierungsdatei (.cpp) implementiert werden. Dem Funktionsnamen muss dabei der Klassenname gefolgt von $::$ vorangestellt werden. (Beispiel: $int$ $Stack::pop()$)
			\end{compactitem}
	\end{minipage}
	\hspace*{0.5cm}
	\begin{minipage}[t]{9 cm}
			\subsubsection{Klassifizierung von Elementfunktionen}
				\begin{compactitem}
					\item Konstruktoren / Destruktoren
						\begin{compactitem}
							\item Konstruktor: erzeugen eines Objekts
							\item Destruktur: vernichten, freigeben eines Objekts
						\end{compactitem}
					\item Modifikatoren
						\begin{compactitem}
							\item ändern den Zustand eines Objekts (Attribute ändern)
						\end{compactitem}
					\item Selektoren
						\begin{compactitem}
							\item greifen nur lesend auf ein Objekt zu (immer const definieren!)
							\item Beispiel: $bool$ $Stack::isEmpty()$ $const;$
						\end{compactitem}
					\item Iteratoren
						\begin{compactitem}
							\item Erlauben, auf Elemente eines Objekts in einer definierten Reihenfolge	zuzugreifen
						\end{compactitem}
				\end{compactitem}
	\end{minipage}
		
	\begin{minipage}[t]{9cm}
			\subsubsection{$inline$-Funktionen \verweiscpp{11.2.1}}
				\begin{compactitem}
					\item Elementfunktionen, die innerhalb der Deklaration der Klassenschnittstelle (im	.h-File) implementiert sind, werden als (implizite) $inline$ - Funktionen
					behandelt.
					\item Elementfunktionen können in der Klassenimplementation explizit mit dem
					Schlüsselwort $inline$ gekennzeichnet werden.
					\item Implizite $inline$ - Funktionen verletzen zwar das Information Hiding Prinzip	und sollten deshalb grundsätzlich vermieden werden.
					\item Jedoch: die impliziten $inline$ - Funktionen sind die Funktionen, die garantiert immer $inline$ verwendet werden (mit einigen wenigen
					Ausnahmen).
				\end{compactitem}	
	\end{minipage}
	\hspace*{0.5cm}
	\begin{minipage}[t]{9 cm}			
			\subsubsection{$const$ - Elementfunktion \verweiscpp{11.2.2}}
				\begin{compactitem}
					\item Elementfunktionen, die den Zustand eines Objekts nicht ändern (Selektoren)
					sollen explizit mit dem Schlüsselwort $const$ gekennzeichnet werden.
					\item Das Schlüsselwort $const$ muss sowohl im Prototypen als auch in der
					Implementierung geschrieben werden.
				\end{compactitem}
				\lstinputlisting[language=C++,tabsize=2]{code/elementfunktion_const.cpp} 
	\end{minipage}
\newpage	
	\begin{minipage}[t]{6cm}
			\paragraph{$mutable$ - Attribut}
				Ein Datenelement, das nie $const$ werden soll (auch nicht bei $const$-Elementfunktionen) kann	mit	$mutable$ gekennzeichnet werden.
				\lstinputlisting[language=C++,tabsize=2]{code/mutable.cpp}
	\end{minipage}
	\hspace*{0.5cm}
	\begin{minipage}[t]{12cm}			
		\subsection{$this$ - Pointer \verweiscpp{11.3}}
			Der $this$-Pointer ist ein Pointer auf das eigene aktuelle Objekt, welches eine
			Methode aufgerufen hat.
			\lstinputlisting[language=C++,tabsize=2]{code/this_pointer.cpp}
			
		\subsection{$static$ - Klassenelemente \verweiscpp{11.5}}
			\begin{compactitem}
				\item Grundsätzlich besitzt jedes Objekt einer Klasse seine eigene private Instanz
				aller Attribute einer Klasse.
				\item Wenn ein Attribut mit $static$ gekennzeichnet wird, dann teilen sich alle
				Objekte dieser Klasse eine einzige Instanz dieses Attributs, d.h. ein
				statisches Attribut ist nur einmal für alle Objekte einer Klasse im Speicher
				vorhanden.
				\item $static$ - Elemente befinden sich ausserhalb eines Objektkontexts.
				\item $static$ - Elemente können auch über den Klassennamen angesprochen
				werden (da sie sich im Kontext einer Klasse befinden).
			\end{compactitem}
	\end{minipage}
	
	\subsection{Konstruktor (am Beispiel der Klasse $TString$) \verweiscpp{11.7.1}}
		\begin{minipage}[t]{9cm}
			\subsubsection{Aufgaben des Konstruktors}
				\begin{compactitem}
					\item die Neugründung eines Objekts einer Klasse
					\item das saubere Initialisieren des Objekts, d.h. alle Attribute des Objekts
					müssen auf einen definierten Wert gesetzt werden
					\item Der Konstruktor hat in $C++$ denselben Namen wie die Klasse, hat keinen
					Rückgabetyp (auch nicht $void$) und kann überladen werden. Beispiel: $Stack::Stack();$ $//(Default-)Konstruktor$
				\end{compactitem}
		\end{minipage}
		\hspace*{0.5cm}
		\begin{minipage}[t]{9cm}
			\subsubsection{Aufruf des Konstuktors}
				\begin{compactitem}
					\item Der Konstruktor soll nie explizit aufgerufen werden.
					\item Der Konstruktor wird vom System automatisch (implizit) aufgerufen, wenn
					ein Objekt erzeugt wird: $Stack$ $s;$
					\item Wenn durch den $new$-Operator Speicher angefordert und erhalten wird,
					dann wird der Konstruktor vom System ebenfalls automatisch aufgerufen: \\ $Stack*$ $pS$ $=$ $new$ $Stack;$
				\end{compactitem}	
		\end{minipage}
		
		\subsubsection{Default-Konstruktor}
			\begin{minipage}[t]{13cm}
				\begin{compactitem}
					\item Der Default-Konstruktor ist der Konstruktor ohne Parameter: \\
					$Stack::Stack();$ \\
					Er wird immer aufgerufen, wenn bei der Objekterzeugung keine Parameter
					mitgegeben werden: \\
					$Stack$ $s;$
					\item Der Default-Konstruktor wird vom System automatisch erzeugt, wenn für
					eine Klasse kein Konstruktor explizit definiert ist.
					\item Der Default-Konstruktor kann selbst definiert werden.
					\begin{compactitem}
						\item Das ist insbesondere dann notwendig, wenn innerhalb des Objekts Speicher
						dynamisch alloziert werden muss (bei der Objekterzeugung).
					\end{compactitem}
				\end{compactitem}
			\end{minipage}
			\hspace*{0.5cm}
			\begin{minipage}[t]{5cm}
				\lstinputlisting[language=C++,tabsize=2]{code/constructor_default.cpp}
			\end{minipage}
\newpage			
		\subsubsection{Implementation/Initialisierung}
			Es gibt zwei Arten den Konstruktor zu implementieren. \\
			\begin{minipage}[t]{9cm}
				\paragraph{Implementation mit Anweisung}
					\lstinputlisting[language=C++,tabsize=2]{code/constructor_init_default.cpp}
			\end{minipage}
			\hspace*{0.5cm}
			\begin{minipage}[t]{9cm}
				\paragraph{Implementation mit Initialisierungsliste}
					\lstinputlisting[language=C++,tabsize=2]{code/constructor_init_list.cpp}
			\end{minipage} \\
			Objektinitialisierungen werden, sofern dies möglich ist, über die Initialisierungsliste des Konstruktors und nicht im Anweisungsteil durchgeführt. (Effizienzgründe) \\
			
		\subsubsection{Überladen von Konstruktoren}
			\begin{minipage}[t]{6cm}
				\begin{compactitem}
					\item Der Default-Konstruktor wird implizit aufgerufen mit \\
					$TString$ $str;$
					\item Ein $TString$-Objekt soll auch z.B. mit folgenden Anweisungen gegründet
					werden können: \\
					$TString$ $str1$ $=$ $"Hello";$ $//$ $implicit$ $call$ \\
					$TString$ $str2$ $=$ $TString("Guten$ $Morgen");$ $//$ $explicit$ $call$
					\item Dazu bedarf es anderer (überladener) Konstruktoren.
				\end{compactitem}
			\end{minipage}
			\hspace*{0.5cm}
			\begin{minipage}[t]{6cm}
				\vspace*{-0.5cm}
				\lstinputlisting[language=C++,tabsize=2]{code/constructor_overload.cpp}
			\end{minipage}
			\begin{minipage}[t]{6cm}
				\vspace*{-0.5cm}
				\lstinputlisting[language=C++,tabsize=2]{code/constructor_overload_implement.cpp}
			\end{minipage}
			
		\subsubsection{Konstruktoren und Function Casts}
			\begin{compactitem}
				\item Konstruktoren mit nur einem Parameter können dazu verwendet werden, ein
				Objekt vom Typ T aus einem anderen Objekt zu erzeugen (Typumwandlung).
				\item Beispiel:	TString soll so erweitert werden, dass dem Konstruktor eine ganze Zahl übergeben wird und dieser daraus den entsprechenden String erzeugt.
				\lstinputlisting[language=C++,tabsize=2]{code/constructor_function_cast.cpp}
			\end{compactitem}
			
		\subsubsection{Explizite Konstruktoren}
			\begin{minipage}[t]{12cm}
				\begin{compactitem}
					\item Die implicit calls (bei Konstruktoren mit einem Parameter) \\
					$TString$ $str2$ $=$ $12345;$ \\
					$str2$ $=$ $789;$ \\
					sind gelegentlich nicht erwünscht.
					\item Wenn der Konstruktor mit $explicit$ gekennzeichnet wird, kann dieser Konstruktor	nicht mehr implizit, sondern nur explizit aufgerufen werden.
					\lstinputlisting[language=C++,tabsize=2]{code/constructor_explicit_1.cpp}
				\end{compactitem}
			\end{minipage}
			\hspace*{0.5cm}
			\begin{minipage}[t]{6cm}
					\vspace*{-0.5cm}
					\lstinputlisting[language=C++,tabsize=2]{code/constructor_explicit_2.cpp}
			\end{minipage}
			
		\subsubsection{Copy-Konstruktor}
			\begin{minipage}[t]{10cm}
				\begin{compactitem}
					\item Der Copy-Konstruktor wird dazu verwendet, Objekte zu kopieren.
					\item Der Copy-Konstruktor erhält als Parameter immer eine konstante Referenz auf
					ein Objekt der Klasse. Für $TString$ sieht er wie folgt aus: 
					$TString(const$ $TString\&$ $s);$
				\end{compactitem}
				Der Copy-Konstruktor wird automatisch aufgerufen, wenn ...
				\begin{compactitem}
					\item ... ein Objekt mit einem anderen Objekt derselben Klasse initialisiert wird.
					\item ... ein Objekt als Wertparameter (by value) an eine Funktion übergeben wird
					(nicht aber bei Referenzparametern).
					\item ... ein Objekt by value als Resultat einer Funktion zurückgegeben wird (nicht bei Referenzrückgabewerten).
				\end{compactitem}
				Ein Copy-Konstruktor wird nur dann benutzt, wenn ein neues Objekt erzeugt wird, aber nicht bei Zuweisungen, also Änderungen von Objekten.
				Bei Zuweisungen wird der vom System bereitgestellte Zuweisungsoperator benutzt,
				sofern kein eigener definiert wurde.
				
				\paragraph{Shallow Copy vs. Deep Copy}
					\begin{compactitem}
						\item Wenn für eine Klasse kein Copy-Konstruktor definiert wird, erzeugt das System einen Standard-Copy-Konstruktor.
						\item Dieser kopiert alle Datenelemente (memberwise assignment). Bei Pointern, welche auf den Heap zeigen, wird nur die Adresse kopiert, nicht aber der Speicher auf dem Heap. Man nennt das shallow copy. (shallow = flach).
						\item Bei einer deep copy werden auch die Speicherbereiche, auf welche Pointer
						zeigen, kopiert. Die deep copy muss in einem selbst definierten Copy-Konstruktor implementiert werden.
					\end{compactitem}
			\end{minipage}
			\hspace*{0.5cm}
			\begin{minipage}[t]{6cm}
				\vspace*{-0.5cm}
				\lstinputlisting[language=C++,tabsize=2]{code/constructor_copy.cpp}
				\lstinputlisting[language=C++,tabsize=2]{code/constructor_copy_2.cpp}
			\end{minipage} \\
			
			\begin{minipage}[t]{9cm}
				\paragraph{Shallow-Copy}
					\includegraphics[width=1\textwidth]{pics/shallow_copy.jpg}
			\end{minipage}
			\hspace*{0.5cm}
			\begin{minipage}[t]{9cm}
				\paragraph{Deep-Copy}
					\includegraphics[width=1\textwidth]{pics/deep_copy.jpg}
			\end{minipage}
			
	\subsection{Destruktor \verweiscpp{11.7.2}}
		\begin{minipage}[t]{7cm}
			\subsubsection{Aufgaben des Destruktors}
				\begin{compactitem}
					\item die vollständige Zerstörung eines nicht mehr benötigten Objekts
					\item das saubere Entfernen eines Objekts
					\item die häufigste Aufgabe ist die Freigabe von nicht mehr benötigtem Speicher auf dem Heap
					\item sehr häufig (wenn kein Speicher auf dem Heap vorhanden ist) wird kein
					Destruktor definiert, da das System dann automatisch aufräumt
				\end{compactitem}
		\end{minipage}
		\hspace*{0.5cm}
		\begin{minipage}[t]{11cm}
			\subsubsection{Eigenschaften des Destruktors}
				\begin{compactitem}
					\item Destruktoren haben keine Argumente und keinen Rückgabetyp
					\item Ihr Name besteht aus dem Klassennamen mit vorgestellter Tilde. Der
					Destruktor soll meist virtual deklariert werden (wenn es einen Destruktor
					braucht): $virtual$ $~TString();$					
					\item Destruktoren werden automatisch aufgerufen, wenn der Gültigkeitsbereich des definierten Objektes ausläuft 
					\item Die Reihenfolge des Aufrufs der Destruktoren ist umgekehrt wie die der
					Konstruktoren
					\item Nicht definierte Destruktoren werden automatisch erzeugt
				\end{compactitem}	
		\end{minipage}
			
	\subsection{Kanonische Form von Klassen \verweiscpp{11.7.5}}
		\begin{compactitem}
			\item Als kanonische Form einer Klasse bezeichnet man jene Form, die es erlaubt,
			eine Klasse wie einen "normalen" Datentyp zu benutzen. Dies ist für alle Klassen anzustreben.
			\item Dazu müssen drei Bedingungen erfüllt sein:
			\begin{compactitem}
				\item Ein korrekter Default-Konstruktor, plus evtl. weitere Konstruktoren müssen
				vorhanden sein
				\item Wenn die Klasse dynamische Daten enthält, braucht es auch einen
				Zuweisungsoperator und einen Copy-Konstruktor
				\item Ein (virtueller) Destruktor garantiert die korrekte Zerstörung von Objekten
			\end{compactitem}
		\end{compactitem}
		
	\subsection{Benutzerdefinierte Typumwandlung \verweiscpp{11.7.6}}
		Wenn zwei ganze Zahlen unterschiedlichen Typs (z.B. $int$ und $short$) addiert werden, so ist der Additionsoperator vom System für folgende Varianten	definiert:
		\begin{compactitem}
			\item $int+int$
			\item $int+short$
			\item $short+int$
			\item $short+short$
		\end{compactitem}
		Wenn nun eine neue Klasse $VeryLargeInt$ eingeführt wird, so sind die Operatoren für diese Klasse noch nicht definiert. Nur schon für den Additionsoperator zwischen $VeryLargeInt$ und $int$ müssten folgende Varianten definiert werden:
		\begin{compactitem}
			\item $int+VeryLargeInt$
			\item $VeryLargeInt+int$
			\item $VeryLargeInt+VeryLargeInt$
		\end{compactitem}
		Dasselbe gilt auch für alle weiteren Operatoren. Für die Grundoperatoren +, -, *,
		/, +=, -=, *=, /= müssten somit 24 Operatoren definiert werden. \\
		Die einfachere Variante ist, wenn für jeden Typ eine Typumwandlung definiert
		wird. Somit braucht es pro Typ eine Umwandlungsfunktion, die Operatoren arbeiten
		anschliessend nur noch mit der Klasse $VeryLargeInt$.
		\begin{compactitem}
			\item $VeryLargeInt+VeryLargeInt$
		\end{compactitem}
		Für die Grundoperatoren +, -, *, /, +=, -=, *=, /= müssten nur noch die 8
		Operatoren definiert werden. Zusätzlich müsste noch die Typumwandlung von jedem Typ ($short$, $int$, etc.) in $VeryLargeInt$ definiert werden. \\
		Häufig werden Typumwandlungen aber auch mit Hilfe von Konstruktoren implementiert:
		$VeryLargeInt(int);$
		
	\subsection{Überladen von Operatoren \verweiscpp{11.7.3}}
		Operatoren (z.B. +, ==, etc.) können wie Funktionen überladen werden.
		
		\subsubsection{Überladbare Operatorfunktionen in C++}
			\begin{minipage}[c]{2.2 cm}
	 			\begin{compactitem}
	 				\item $new$
	 				\item $delete$				
	 				\item $new[$ $]$				
	 				\item $delete[$ $]$ 	
	 				\item $+$
	 				\item $-$							
	 			\end{compactitem}
 			\end{minipage}
 			\begin{minipage}[c]{2.3 cm}
	 			\begin{compactitem}	
	 				\item $*$
	 				\item $/$			
	 				\item $\%$
	 				\item $\textasciicircum$	 
	 				\item $\&$	
	 				\item $|$		
	 			\end{compactitem}
 			\end{minipage}
 			\begin{minipage}[c]{2.2 cm}
	 			\begin{compactitem}	
	 			 	\item $\textasciitilde$
	  			 	\item $!$	
	 			 	\item $=$ 			 	
	 			 	\item $<$ 	
	 			 	\item $>$	 		 	
	 			\end{compactitem}
 			\end{minipage}
 			\begin{minipage}[c]{2.2 cm}
	 			\begin{compactitem}	
	 			 	\item $+=$			 	
	 			 	\item $-=$			 	
	 			 	\item $*=$		
	 			 	\item $/=$	
	 			 	\item $\%=$		 	
	 			\end{compactitem}
	 		\end{minipage}
 			\begin{minipage}[c]{2.2 cm}
	 			\begin{compactitem} 
	 			 	\item $\textasciicircum=$			 	
	 			 	\item $\&=$ 		 	
	 			 	\item $|=$			 	
	 			 	\item $<<$ 		
	 			 	\item $>>$	 	
	 			\end{compactitem}
	 		\end{minipage}
 			\begin{minipage}[c]{2.2 cm}
	 			\begin{compactitem}		 
	 			 	\item $>>=$ 			 	
	 			 	\item $<<=$ 			 	
	 			 	\item $==$ 			 	
	 			 	\item $!=$
	 			 	\item $<=$	
	 			\end{compactitem}
	 		\end{minipage}
 			\begin{minipage}[c]{2.2 cm}
	 			\begin{compactitem}		 	
	 			 	\item $>=$ 		 	
	 			 	\item $\&\&$ 			 	
	 			 	\item $||$ 			 	
	 			 	\item $++$ 		
	 			 	\item $--$	 	
	 			\end{compactitem}
	 		\end{minipage}
 			\begin{minipage}[c]{2.4 cm}
	 			\begin{compactitem}		 	
	 			 	\item $,$ 			 	
	 			 	\item $->*$	
	 			 	\item $->$		 	
	 			 	\item $()$
	 			 	\item $[$ $]$
	 			\end{compactitem}
	 		\end{minipage}
	 		
		\subsubsection{Randbedingungen}
			\begin{compactitem}
				\item Die Anzahl der Operanden (Argumente) muss gleich sein wie beim ursprünglichen Operator.
				\item Die Priorität des überladenen Operators kann nicht ändern.
				\item Neue Operatoren können nicht eingeführt werden.
				\item Default-Argumente sind bei Operatoren nicht möglich.
			\end{compactitem}
			
		\begin{minipage}[t]{9cm}	
			\subsubsection{Operator Overloading als Elementfunktion}
				Der neu definierte Operator wird als Elementfunktion implementiert. Damit ist
				der Zugriff auf $private$ und $protected$ Attribute der Klasse möglich.
				\lstinputlisting[language=C++,tabsize=2]{code/operator_overloading_element.cpp}
				Zwingend als Elementfunktion zu implementieren sind: 
				\begin{compactitem}
					\item Zuweisungsoperator $=$
					\item Indexaufruf $[$ $]$
					\item Funktionsaufruf $()$
					\item Zeigeroperator $->$
				\end{compactitem}
		\end{minipage}
		\hspace*{0.5cm}
		\begin{minipage}[t]{9cm}	
			\subsubsection{Operator Overloading als normale Funktion}
				Die Operatorfunktionen werden meist als normale Funktion implementiert. Dadurch besteht jedoch kein Zugriff mehr auf die $private$ und $protected$ Elemente der Klasse. Die Operatorfunktion muss deshalb als $friend$ deklariert werden.
				\lstinputlisting[language=C++,tabsize=2]{code/operator_overloading_normal.cpp}
		\end{minipage} \\
		
	\subsection{Strukturen und Unionen \verweisboth{11}{11.8.2}}
		\subsubsection{Strukturen \verweisc{11.1}}
			\paragraph{Eigenschaften}
				\begin{compactitem}
					\item Daten, welche logisch zusammengehören, können zusammengenommen werden
					\item Die Struktur ist ein zusammengesetzter Datentyp, sie setzt sich aus den Feldern zusammen
					\item Die einzelnen Felder der Strukturen können (müssen aber nicht) unterschiedliche Typen haben
					\item Jedes Feld wird mit einem innerhalb der Struktur eindeutigen Namen versehen $\rightarrow$ Strukturspezifische Präfixe für die Feldnamen (z.B. $Angestellter\_Vorname$) sind deshalb sinnlos. 
				\end{compactitem}
			
			\begin{minipage}[t]{10 cm}
				\paragraph{Definition von Strukturtypen}
					\vspace*{-0.2cm}
					\lstinputlisting[language=C,tabsize=2]{code/strukturen1.c}
					\vspace*{0.3cm}
					\begin{compactitem}
						\item $StructName$ kann frei gewählt werden
						\item $struct$ $StructName$ ist hier ein selbst\\ definierter Typ, der weiter verwendet werden kann
						\item Der Datentyp ist definiert durch den Inhalt der\\ geschweiften Klammer
						\item Der Feldtyp kann wiederum eine Struktur sein
					\end{compactitem}
			\end{minipage}
			\hspace*{0.5cm}	
			\begin{minipage}[t]{8 cm}
				\paragraph{Beispiel}
					\vspace*{-0.2cm}
					\lstinputlisting[language=C,tabsize=2]{code/strukturen2.c}
			\end{minipage}
\newpage		
			\paragraph{Beispiele für die Definition von Strukturvariablen}
				\vspace*{-0.2cm}
				\lstinputlisting[language=C,tabsize=2]{code/strukturen3.c}
				\vspace*{0.3cm}	
					
			\paragraph{Operationen auf Strukturvariablen}
				\begin{compactitem}
					\item Zuweisung: liegen zwei Strukturvariablen a und b vom gleichen Strukturtyp vor, so kann der Wert der einen Variablen der anderen zugewiesen werden $\rightarrow$ $a=b;$
					\item Ermittlung der Grösse der Struktur: mit $sizeof$-Operator
					\item Ermittlung der Adresse der Strukturvariablen: mit Adressoperator $\&$
				\end{compactitem}
				
			\paragraph{Zugriff auf eine Strukturvariable und deren Felder}
				Der Zugriff auf ein Feld einer Strukturvariablen erfolgt über
				\begin{compactitem}
					\item den Namen der Strukturvariablen,
					\item gefolgt von einem Punkt
					\item und dem Namen des Feldes 
				\end{compactitem}			
				\vspace*{0.2cm}
				... wenn der Zugriff über einen Pointer auf eine Strukturvariable erfolgt, über
				\begin{compactitem}
					\item den Namen des Pointers,
					\item gefolgt von einem Pfeil (--\textgreater)
					\item und dem Namen des Feldes 
				\end{compactitem}
							
			\paragraph{Beispiele für den Zugriff auf eine Strukturvariable}
				\vspace*{-0.2cm}
				\lstinputlisting[language=C,tabsize=2]{code/strukturen4.c}
				\vspace*{0.3cm}
\newpage
			\begin{minipage}[c]{8 cm}
				\paragraph{Lage im Speicher}
					\begin{compactitem}
						\item Die Felder einer Strukturvariablen werden nacheinander gemäss der Definition in den Speicher gelegt.
						\item Gewisse Datentypen verlangen unter Umständen, dass sie auf eine Wortgrenze (gerade Adresse) gelegt werden. Dies nennt man Alignment.
						\item Durch das Alignment kann es vorkommen, dass einzelne Bytes nicht verwendet werden, d.h. im Speicher ausgelassen werden.
						\item Die Grösse einer Strukturvariablen kann nicht durch Addieren der Grössen der Felder ermittelt werden, nur $sizeof()$ liefert den genauen Wert
					\end{compactitem}
			\end{minipage}
			\hspace*{2cm}
			\begin{minipage}[c]{7 cm}
				\includegraphics[width=0.5\textwidth]{pics/alignment.png}
			\end{minipage}
			\hspace*{-3cm}	
			\begin{minipage}[c]{3 cm}
				\lstinputlisting[language=C,tabsize=2]{code/strukturen5.c}
				\vspace*{0.5cm}
				Das int-Feld zahl muss auf einer geraden Adresse beginnen!
			\end{minipage}
			
			\paragraph{Übergabe und Rückgabe von Strukturvariablen}
				\begin{compactitem}
					\item Strukturvariablen können komplett an Funktionen übergeben werden
					\item Der Rückgabetyp einer Funktion kann eine Struktur sein. Dabei wird die Strukturvariable direkt komplett übergeben
					\item Zu beachten ist der Kopieraufwand bei der Übergabe, bzw. Rückgabe eines Wertes. In der Praxis soll deshalb mit Pointern gearbeitet werden!
					\lstinputlisting[language=C,tabsize=2]{code/strukturen7.c} 
				\end{compactitem}
			
			\paragraph{Initialisierung einer Strukturvariablen}
				Eine Initialisierung einer Strukturvariablen kann direkt bei der Definition der Strukturvariablen mit Hilfe einer Initialisierungsliste durchgeführt werden (Reihenfolge beachten). Natürlich muss der Datentyp $struct$ $Angestellter$ bereits bekannt sein. 
				\lstinputlisting[language=C,tabsize=2]{code/strukturen6.c} 	
							
		\subsubsection{Unions \verweisboth{11.2}{11.8.2}}
			\paragraph{Eigenschaften}
				\begin{compactitem}
					\item ähnlich wie Struktur
					\item beinhaltet auch mehrere Felder unterschiedlichen Typs
					\item im Gegensatz zur Struktur ist aber nur ein einziges Feld jeweils aktiv (abhängig vom Typ)
					\item Die Grösse einer $Union$ ist so gross wie das grösste Feld der $Union$
					\item Bei der Union sind dieselben Operationen wie bei einer Struktur definiert 
				\end{compactitem}	
			\begin{minipage}[t]{10 cm}
				\paragraph{Definition von Uniontypen}
					\vspace*{-0.2cm}
					\lstinputlisting[language=C,tabsize=2]{code/unions1.c}
					\vspace*{0.3cm}
						\begin{compactitem}
							\item $UnionName$ kann frei gewählt werden
							\item $union$ $UnionName$ ist ein hier selbst definierter Typ, \\der weiter verwendet werden kann
							\item Der Datentyp ist definiert durch den Inhalt der \\geschweiften Klammer
							\item Der Feldtyp kann wiederum eine Union oder \\auch eine Struktur sein
						\end{compactitem}
			\end{minipage}
			\hspace*{1.5cm}	
			\begin{minipage}[t]{8 cm}
				\paragraph{Beispiel}
					\vspace*{-0.2cm}
					\lstinputlisting[language=C,tabsize=2]{code/unions2.c}
					\vspace*{0.5cm}
					\includegraphics[width=0.5\textwidth]{pics/union.png}
			\end{minipage}
			\vspace*{0.8cm}
			
		\subsubsection{Allgemeines zu Strukturen und Unions}
			\paragraph{Codierstil}
				\begin{compactitem}
					\item $Strukturname$ und $Unionname$ mit einem grossen Buchstaben beginnen!\\
					$struct$ $Angestellter;$\\
					$union$ $Vario;$
					\item Struktur- und Unionvariablen mit einem kleinen Buchstaben beginnen
					\item Bei Feldern von $Strukturen$ und $Union$ soll kein Präfix bei den Feldnamen verwendet werden
				\end{compactitem}
				
			\paragraph{Vorsicht bei Unions}	
				\begin{compactitem}
					\item Der Programmierer muss verfolgen, welcher Typ jeweils in der $Union$ gespeichert ist. Der Datentyp, der entnommen wird, muss der sein, der zuletzt gespeichert wurde. 
				\end{compactitem}			